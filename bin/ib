#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
# vim: filetype=ruby

self_file =
  if File.symlink?(__FILE__)
    require 'pathname'
    Pathname.new(__FILE__).realpath
  else
    __FILE__
  end
$:.unshift(File.dirname(self_file) + "/../lib")

require 'immutablebox'

tracker = 'http://localhost:6969/announce'
priv = true
name = File.basename(FileUtils.pwd)
IB_DIR_GAP = "#{IB_DIR}/gap"
IB_DIR_TORRENTS = "#{IB_DIR}/torrents/#{name}"
IB_DIR_PIECES = "#{IB_DIR}/pieces"
storage = LocalStorage.new(IB_DIR_PIECES)

def get_last_torrent
  return unless File.directory? IB_DIR_TORRENTS
  torrent = Dir.entries(IB_DIR_TORRENTS).sort_by{|dir| dir.split.first.to_i}
  return if torrent.size == 2 # '.', '..'
  File.join(IB_DIR_TORRENTS, torrent.last)
end

command = (ARGV.shift or 'help').to_sym
case command
when :commit, :ci
  gap = !ARGV.shift.nil?
  img = make_torrent(name, '.', tracker, priv, gap)
  torrentfile = "#{IB_DIR_TORRENTS}/#{Time.now.to_i}.torrent"
  File.open(torrentfile, 'wb') do |fd|
    fd.write(img)
  end
  begin
    storage.open
    load_torrent(torrentfile) do |piece_hash, piece|
      storage.put(piece_hash, piece)
    end
  ensure
    storage.close
  end
when :init
  FileUtils.mkdir_p IB_DIR_GAP
  FileUtils.mkdir_p IB_DIR_TORRENTS
  FileUtils.mkdir_p IB_DIR_PIECES
when :log
  exit unless File.directory? IB_DIR_TORRENTS
  Dir.entries(IB_DIR_TORRENTS).each do |dir|
    next unless /\.torrent\z/ === dir
    puts Time.at(dir.split.first.to_i)
  end
when :status, :st
  torrent = get_last_torrent
  exit unless torrent
  torrentobj = Torrent.new(torrent)
  begin
    storage.open
    changes = load_torrent(torrent) do |piece_hash, piece|
    end
    changes.each do |file|
      puts "M #{file}"
    end
    trackedfiles = torrentobj.info.files.map do |file|
      if file['path'][0] != IB_DIR
        file['path'].join('/')
      end
    end
    allfiles = []
    walk('.') do |file|
      next if file.index("./#{IB_DIR}/") == 0
      filename = file.split('/', 2).last
      puts "? #{filename}" unless trackedfiles.include?(filename)
    end
  ensure
    storage.close
  end
when :update, :up
  torrent = get_last_torrent
  exit unless torrent
  begin
    storage.open
    changes = load_torrent(torrent) do |piece_hash, piece|
    end
    save_torrent(torrent, storage, changes)
  ensure
    storage.close
  end
when :verify
  p :verify
else
  p :help
end
